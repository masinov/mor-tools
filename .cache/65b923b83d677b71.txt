# Enhanced CP-SAT Model Integration Guide

## Repository Architecture

This codebase extends Google's OR-Tools CP-SAT solver with enhanced functionality through a mixin-based architecture. The core components are:

- **EnhancedCpModel** (`model/model.py`): Main model class that inherits from `CpModel` and combines all mixins
- **Mixin Classes**: Modular functionality added through multiple inheritance:
  - `_ConstraintsMixin`: Enhanced constraint management with tracking
  - `_VariablesMixin`: Extended variable creation methods
  - `_ObjectivesMixin`: Objective function management
  - `_DebugMixin`: Debugging and infeasibility analysis tools
  - `_IOMixin`: Import/export capabilities
- **Constructor Tools** (`model/constructor_tools.py`): Helper functions for creating complex boolean expressions
- **Constraint Proxy** (`model/constraints.py`): Wrapper for constraint manipulation

## Module Dependencies

```
EnhancedCpModel (model.py)
    ├── _ConstraintsMixin (constraints.py)
    │   └── ConstraintInfo, _ConstraintProxy
    ├── _VariablesMixin (variables.py)
    ├── _ObjectivesMixin (objectives.py)
    ├── _DebugMixin (debug.py)
    ├── _IOMixin (io.py)
    └── EnhancedConstructorsMixin (constructors.py)
        └── Constructor Tools (constructor_tools.py)*
            ├── NewAndBoolVar, NewOrBoolVar, NewEqualBoolVar, etc.
            └── M (helper class)
```

*Note: Constructor tools are imported as functions, not as direct dependencies*

### Import Patterns

```python
# Core model creation
from model.model import EnhancedCpModel

# Constructor tools (optional)
from model.constructor_tools import NewAndBoolVar, NewOrBoolVar

# Typical usage
model = EnhancedCpModel()
```

## API Usage Patterns

### Basic Model Creation
```python
from model.model import EnhancedCpModel

model = EnhancedCpModel()
```

### Variable Creation
```python
# Standard variables
x = model.NewIntVar(0, 10, 'x')
b = model.NewBoolVar('b')

# Enhanced functionality (tracked variables)
y = model.NewIntVar(0, 100, 'y', track=True)
```

### Constraint Management
```python
# Standard constraints (automatically tracked)
model.Add(x + y <= 15)

# Enhanced constraints with names and enforcement
model.Add(x == 5, name='x_fixed').OnlyEnforceIf(b)

# Complex boolean expressions
b_and = model.NewAndBoolVar([b1, b2, b3])
model.Add(x > 0).OnlyEnforceIf(b_and)
```

### Objective Functions
```python
# Minimization
model.Minimize(x + 2*y)

# Maximization  
model.Maximize(3*x - y)
```

### Debugging
```python
# Check for infeasibility
if model.debug_infeasible():
    print("Model is infeasible")
    
# Create subset for debugging
subset = model.create_subset_copy(['constraint1', 'constraint2'])
```

### Import/Export
```python
# Export model
model.export_to_file('model.zip')

# Import model  
new_model = EnhancedCpModel()
new_model.import_from_file('model.zip')
```

## Integration Points

### 1. Constraint Registration System
- All constraints are wrapped in `_ConstraintProxy`
- `ConstraintInfo` tracks enforcement literals and metadata
- `_register_constraint()` handles the registration process

### 2. Variable Mapping
- `_map_expr_to_new_model()` and `_deep_map_expr()` handle expression recreation
- Essential for model copying and import/export functionality

### 3. Serialization System
- `_serialize_arg()` and `_deserialize_arg()` handle complex data types
- JSON-based metadata storage alongside protobuf model

### 4. Constructor Tools Integration
- Boolean expression helpers integrate seamlessly with constraint enforcement
- All tools return variables compatible with the constraint system

## Potential Issues

### Missing Imports (Critical)
The analysis shows numerous undefined references that will cause runtime errors:

```python
# Missing in constraints.py
from ortools.sat.python import cp_model as _cp
from ortools.sat.python.cp_model import LinearExpr, Domain

# Missing in various files
import json
import zipfile
import random
from ortools.sat import cp_model_pb2
```

### Circular Dependency Risks
- `constructors.py` depends on `constructor_tools.py`
- All mixins depend on the base `EnhancedCpModel`
- Careful import ordering required

### Interface Mismatches
- Constructor tools expect certain methods (`model.Add`, `model.NewBoolVar`) that must be available
- Serialization system assumes specific variable and constraint interfaces

### Performance Considerations
- Constraint tracking adds overhead
- Deep expression mapping can be expensive for large models
- Serialization creates additional memory usage

## Quick Start Guide

### 1. Installation and Setup
```python
# Install required packages
pip install ortools

# Import the enhanced model
from model.model import EnhancedCpModel
```

### 2. Basic Model Creation
```python
model = EnhancedCpModel()

# Create variables
x = model.NewIntVar(0, 10, 'x')
y = model.NewIntVar(0, 10, 'y')
b = model.NewBoolVar('b')

# Add constraints
model.Add(x + y <= 15)
model.Add(x >= 5).OnlyEnforceIf(b)

# Set objective
model.Maximize(x + 2*y)
```

### 3. Using Constructor Tools
```python
from model.constructor_tools import NewAndBoolVar, NewOrBoolVar

# Create complex boolean expressions
b1 = model.NewBoolVar('b1')
b2 = model.NewBoolVar('b2')
b3 = model.NewBoolVar('b3')

and_var = NewAndBoolVar(model, [b1, b2, b3])
or_var = NewOrBoolVar(model, [b1, b2, b3])

# Use in constraints
model.Add(x > 0).OnlyEnforceIf(and_var)
```

### 4. Debugging and Analysis
```python
# Check model status
if model.debug_infeasible():
    print("Model is infeasible - checking constraints...")
    
# Export for later use
model.export_to_file('my_model.zip')

# Create a subset for focused debugging
subset = model.create_subset_copy(['main_constraint', 'secondary_constraint'])
```

### 5. Advanced Usage
```python
# Import existing model
loaded_model = EnhancedCpModel()
loaded_model.import_from_file('my_model.zip')

# Work with constraint metadata
for constraint_name, constraint_info in model._constraints.items():
    print(f"Constraint {constraint_name} has {len(constraint_info.user_enforcement_literals)} enforcement literals")
```

## Best Practices

1. **Always use named constraints** for better debugging: `model.Add(expr, name='constraint_name')`
2. **Enable tracking** for important variables: `model.NewIntVar(0, 10, 'x', track=True)`
3. **Use constructor tools** for complex boolean logic rather than manual construction
4. **Export models** before major changes for easy rollback
5. **Use the debug tools** early to catch infeasibility issues

This architecture provides powerful extensions to the standard CP-SAT model while maintaining backward compatibility with existing OR-Tools code.